---
title: "Workflows"
description: "Build Workflow with background functions"
---

## Prerequisites

<Card
  title="Defer basics"
  href="/features/cron"
  icon={
    <>
      <svg
        width="24"
        height="24"
        viewBox="0 0 40 41"
        fill="none"
        xmlns="http://www.w3.org/2000/svg"
        className="hidden dark:block"
      >
        <path
          fillRule="evenodd"
          clipRule="evenodd"
          d="M40 0.5V40.5H0V0.5H40ZM15.7143 4.78571H4.28571V16.2143H15.7143V4.78571ZM4.28571 20.5H20V4.78571H25.7143V26.2143H4.28571V20.5ZM4.28571 36.2143V30.5H30V4.78571H35.7143V36.2143H4.28571Z"
          fill="white"
        />
      </svg>
      <svg
        width="24"
        height="24"
        viewBox="0 0 40 41"
        fill="none"
        xmlns="http://www.w3.org/2000/svg"
        className="block dark:hidden"
      >
        <path
          fillRule="evenodd"
          clipRule="evenodd"
          d="M40 0.5V40.5H0V0.5H40ZM15.7143 4.78571H4.28571V16.2143H15.7143V4.78571ZM4.28571 20.5H20V4.78571H25.7143V26.2143H4.28571V20.5ZM4.28571 36.2143V30.5H30V4.78571H35.7143V36.2143H4.28571Z"
          fill="black"
        />
      </svg>
    </>
  }
>
  Get familiar with background functions
</Card>

## Overview

Defer allows background functions to call other background functions, making building workflows intuitive.

Build asynchronous Workflows by applying recursion and mapping patterns to background functions, as follows:

<CodeGroup>

```tsx defer/weeklyProductRecommendations.ts
import { defer } from "@defer/client";
// Import the other background function we use in or workflow
import computeProductRecommendation from "./computeProductRecommendation";

const weeklyProductRecommendations = async () => {
  const users = await prisma.user.find({
    where: {
      weeklyProductRecommendations: true,
    },
  });

  // computeProductRecommendation() calls will run on the Defer Platform,
  //  in parallel
  users.forEach(computeProductRecommendation);
};

export default defer(weeklyProductRecommendations);
```

```ts defer/computeProductRecommendation.ts
import { defer } from "@defer/client";
import { User } from "../prisma/generated/client";

const computeProductRecommendation = async (user: User) => {
  // 1. compute product recommendations ...
  // 2. send email
};

export default defer(computeProductRecommendation, { concurrency: 10 });
```

</CodeGroup>

<br />

<Info>
**What happen when a workflow fails with retries configured?**

For now, any failure that happen during the workflow will retry the whole workflow from the beginning.

We are planning to add better Control Flow and idempotency APIs in a near future.

</Info>

## Full example: User onboarding workflow

Application user onboardings tend to compose multiple actions (sending emails) that might spread across multiple steps over time.

For example, when a user onboards, we might want to immediately:

- send a welcome email
- trigger a Hubspot contacts sync

then, make the user as onboarded and, a few days later: send a tutorial if the user is not engaged.

While such workflow can be implemented in a distributed way, in a event-based architecture, or with CRONs, **Defer offers a context-switch free and code-first way to implement such workflows**.

Before jumping into the user onboarding workflow implementation, let's see how Defer enables to run background functions in parallel while waiting for their result, as needed in:

> when a user onboards, we might want to immediately:
>
> - send a welcome email
> - trigger a Hubspot contacts sync
>
> then, make the user as onboarded [...]

### Running background functions in parallel

Given the following project:

```
- src/
  - defer/
    - importContactsFromHubspot.ts â¬…
    - sendWelcomeEmail.ts â¬…
    - sendTutorialsEmailIfNoActions.ts â¬…
    - userOnboarding.ts â¬…
  - ...
- package.json
- .env
- ...
```

We want to call trigger and wait for the execution of `importContactsFromHubspot()` and `sendWelcomeEmail()`, in parallel.

For this, will use the `awaitResult()` API, as follows:

```tsx src/demoParallelRuns.ts
import { defer } from "@defer.run/client";
import importContactsFromHubspot from "./defer/importContactsFromHubspot";
import sendWelcomeEmail from "./defer/sendWelcomeEmail";

async function myDemo() {
  const user = {
    /* ... */
  };

  // run the background functions immediately in parallel and wait for the results
  const results = await Promise.allSettled([
    awaitResult(importContactsFromHubspot)(user),
    awaitResult(sendWelcomeEmail)(user),
  ]);
}
```

If the background function execution succeded, `awaitResult()` will return the value returned by the function.

If it failed, it will raise an error (the one raised by the background function or a generic one.)

Now that we saw how to run multiple background functions in parallel to get their results, let's see how to write our user onboarding workflow.

### Writing a workflow with Defer

Writing workflows with Defer is simple, **just call other background functions** from your main background function.

Our `userOnboarding()` function would call other functions and execute as follow:

<Frame>
  <img
    src="/images/features/workflows/workflow.png"
    alt="Hubspot contacts import workflow"
  />
</Frame>

As stated earlier, implementing such a workflow is achieved with simple background functions calls:

```tsx src/userOnboarding.ts
import { delay, defer } from "@defer/client";
import sendWelcomeEmail from "./sendWelcomeEmail";
import importContactsFromHubspot from "./importContactsFromHubspot";
import sendTutorialsEmailIfNoActions from "./sendTutorialsEmailIfNoActions";

async function userOnboarding(user: User) {
  await Promise.allSettled([
    awaitResult(importContactsFromHubspot)(user),
    awaitResult(sendWelcomeEmail)(user),
  ]);

  // once the Hubspot data is synced and the welcome mail sent,
  //  let's flagged the user as onboarded
  await prisma.user.update({
    where: { id: user.id },
    data: { onboarded: true },
  });

  const sendTutorialsEmailIfNoActionsDelayed = delay(
    sendTutorialsEmailIfNoActions,
    "1 day"
  );
  await sendTutorialsEmailIfNoActionsDelayed(user);
}

export default defer(userOnboarding);
```

Congrats, you implemented your first workflow with Defer ðŸŽ‰

You can start this workflow from your application's API like any background function: `userOnboarding(user)`.

Your workflow will benefit of all Defer's features:

- Analytics and logs on Defer dashboard
- Smart retries on child background failures
- Slack notification on workflow failures
- Cancel and re-run workflow from the Defer dashboard
